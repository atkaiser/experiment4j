experiment4j
============

Summary
-------
A Java port of Github's [Science framework](https://github.com/github/dat-science).

Motivation
----------
I read ["Move Fast, Break Nothing"](http://zachholman.com/talk/move-fast-break-nothing/) by Zack Holman, and I 
really wanted the capabilities of Github's [Science framework](https://github.com/github/dat-science) in Java 8.

I work with a large production system where we are actively trying to replace a bunch of legacy code with
newer implementations. Are core goals are to: 
* Improve performance
* Maintain backwards compatibility

With those objectives, Science is exactly the thing we need. The ability to allow developers to easily and consistently express the capability to quickly perform these kinds of experiments with a DSL is vital.

Methodology
-----------
I based this implementation on reading the Science documentation, and building out the capabilities from the
functionality expressed there. In other words, I did not focus on porting the implementation. No doubt, greater insight could be gained from spending more time on grokking the Ruby implementation, but it was faster for me to work directly from the docs, and build what I needed from my own understanding of the pattern.

Dependencies
------------
The only dependency for this framework is on the [Javaslang framework](http://javaslang.com/) for convenient Functional monads. 

Domain Concepts
---------------
There are only a few main domain concepts for this framework:

* _Experiment_: a wrapper around 2 implementations of the same business logic: the _Control_ and the _Candidate_. The wrapper   1. Runs the _Control_ and _Candidate_ implementations in parallel (using a thread executor)
  2. Times the execution of both the _Control_ and _Candidate_
  3. Compares the results for equality
  3. Pushes the comparison data (generated in 2 and 3 above) to a _Publisher_
  4. Returns the response of the _Control_ to the calling code
* _Science_: the baseline configuration for Experiments. A _Science_ instance is a factory for _Experiment_ instances
* _Control_: The default version of business logic to be run during an _Experiemnt_. The response from the _Control_ will always be returned by an _Experiment_
* _Candidate_: The experimental version of business logic to be run in an _Experiment_. The response from the _Candidate_ will never be returned by an _Experiment_
* _Publisher_: An interface for outputting the data generated by an _Experiment_, such as _Control_ and _Candidate_ response times, and whether the output of the two functions match. Usually, this will be an adapter to a Metrics framework, such as [CodaHale Metrics](https://github.com/codahale/metrics).

DSL Syntax
----------
The DSL Syntax is under construction, but an example of the current iteration is here: [DSL Test](https://github.com/dannwebster/experiment4j/blob/master/src/test/java/com/crypticmission/exp/ExperimentTest.java).
The main issue with this is that the distinction between building an instance of _Science_ (the factory that holds the 
baseline _Experiment_ configuration), and the _Experiment_ itself.

The goal of the DSL is to mimic the Ruby syntax of the [Science framework](https://github.com/github/dat-science),
but without causing any unexpected side effects.

The current DSL has the unexpected side effect of redefining both the Science and the Experiment instances each time it is
executed. Any final version of the framework should allow you to define both the Science and the Experiment in line, but
only construct the instance once. (see [Issue #1](https://github.com/dannwebster/experiment4j/issues/1) to track this)

